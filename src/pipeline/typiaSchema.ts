import { dirname } from "node:path";
import ts from "typescript";
import typiaTransform from "typia/lib/transform";

export type JsonObject = Record<string, unknown>;
export type SchemaCollection = {
	components?: {
		schemas?: Record<string, unknown>;
	};
};

const createSchemaCollectionSource = (
	typesSource: string,
	rootName: string,
): string => {
	return [
		'import typia from "typia";',
		typesSource.trim(),
		`export const schemaCollection = typia.json.schemas<[${rootName}], "3.1">();`,
	].join("\n");
};

const compileSchemaCollection = (
	typesSource: string,
	rootName: string,
): SchemaCollection => {
	const virtualFile = "virtual-types.ts";
	const sourceText = createSchemaCollectionSource(typesSource, rootName);
	const options: ts.CompilerOptions = {
		module: ts.ModuleKind.CommonJS,
		target: ts.ScriptTarget.ES2020,
		moduleResolution: ts.ModuleResolutionKind.NodeJs,
		strict: true,
		esModuleInterop: true,
		skipLibCheck: true,
	};

	const baseHost = ts.createCompilerHost(options);
	const diagnostics: ts.Diagnostic[] = [];
	const extras = {
		addDiagnostic: (diag: ts.Diagnostic) => {
			diagnostics.push(diag);
			return diagnostics.length - 1;
		},
	};

	const host: ts.CompilerHost = {
		...baseHost,
		fileExists: (fileName) =>
			fileName === virtualFile || baseHost.fileExists(fileName),
		readFile: (fileName) =>
			fileName === virtualFile ? sourceText : baseHost.readFile(fileName),
		getSourceFile: (
			fileName,
			languageVersion,
			onError,
			shouldCreateNewSourceFile,
		) => {
			if (fileName === virtualFile) {
				return ts.createSourceFile(fileName, sourceText, languageVersion, true);
			}
			return baseHost.getSourceFile(
				fileName,
				languageVersion,
				onError,
				shouldCreateNewSourceFile,
			);
		},
	};

	const program = ts.createProgram([virtualFile], options, host);
	let outputText = "";

	program.emit(
		undefined,
		(fileName, content) => {
			if (fileName.endsWith(".js")) {
				outputText = content;
			}
		},
		undefined,
		false,
		{
			before: [typiaTransform(program, undefined, extras)],
		},
	);

	if (diagnostics.length > 0) {
		const formatted = ts.formatDiagnosticsWithColorAndContext(diagnostics, {
			getCanonicalFileName: (fileName) => fileName,
			getCurrentDirectory: () => process.cwd(),
			getNewLine: () => "\n",
		});
		throw new Error(`Typia transform failed:\n${formatted}`);
	}

	if (!outputText) {
		throw new Error("Failed to emit schema collection output.");
	}

	const module = { exports: {} as { schemaCollection?: SchemaCollection } };
	const runner = new Function(
		"exports",
		"require",
		"module",
		"__filename",
		"__dirname",
		outputText,
	);
	const virtualDir = dirname(virtualFile);
	runner(module.exports, require, module, virtualFile, virtualDir);

	const collection = module.exports.schemaCollection;
	if (!collection || typeof collection !== "object") {
		throw new Error("Schema collection was not generated.");
	}

	return collection;
};

const normalizeRefs = (value: unknown): unknown => {
	if (Array.isArray(value)) {
		return value.map((entry) => normalizeRefs(entry));
	}

	if (!value || typeof value !== "object") {
		return value;
	}

	const entries = Object.entries(value as Record<string, unknown>);
	const normalized: Record<string, unknown> = {};
	for (const [key, entry] of entries) {
		if (key === "$ref" && typeof entry === "string") {
			normalized[key] = entry.replace("#/components/schemas/", "#/$defs/");
			continue;
		}

		normalized[key] = normalizeRefs(entry);
	}

	return normalized;
};

export type JsonSchemaResult = {
	collection: SchemaCollection;
	schema: JsonObject;
};

export const generateJsonSchemaFromTypes = (
	typesSource: string,
	rootName: string,
): JsonSchemaResult => {
	const collection = compileSchemaCollection(typesSource, rootName);
	const components = collection.components?.schemas;
	if (!components || typeof components !== "object") {
		throw new Error("Schema components were not generated by typia.");
	}

	const rootSchema = (components as Record<string, unknown>)[rootName];
	if (!rootSchema || typeof rootSchema !== "object") {
		throw new Error(`Root schema not found: ${rootName}`);
	}

	const normalizedDefs = normalizeRefs(components) as Record<string, unknown>;
	const normalizedRoot = normalizeRefs(rootSchema) as Record<string, unknown>;

	const outputSchema: JsonObject = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		...normalizedRoot,
		$defs: normalizedDefs,
	};

	if (!outputSchema.title) {
		outputSchema.title = rootName;
	}

	return {
		collection,
		schema: outputSchema,
	};
};
